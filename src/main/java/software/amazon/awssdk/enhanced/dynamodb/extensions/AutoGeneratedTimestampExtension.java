package software.amazon.awssdk.enhanced.dynamodb.extensions;

import lombok.Builder;
import lombok.Getter;
import software.amazon.awssdk.enhanced.dynamodb.AttributeValueType;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClientExtension;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbExtensionContext;
import software.amazon.awssdk.enhanced.dynamodb.Expression;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTag;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableMetadata;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;

import java.time.Instant;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static software.amazon.awssdk.enhanced.dynamodb.internal.EnhancedClientUtils.isNullAttributeValue;

/**
 * DynamoDB Enhanced Extension which mimics the functionality provided by annotation @DynamoDBAutoGeneratedTimestamp
 * in the DynamoDB Mapper within SDK 1.11
 *
 * AttributeType gets converted to a String and will get read back to Instant.
 * DynamoDB Enhanced already supports converting Instant to string and string to Instant, which is
 * why there is no afterRead function implemented.
 */
public final class AutoGeneratedTimestampExtension implements DynamoDbEnhancedClientExtension {

    private static final String CUSTOM_METADATA_KEY = "AutoGeneratedTimestampExtension:AutoGeneratedTimestamp";
    private static final AutoGeneratedTimestamp AUTO_GENERATED_TIMESTAMP_ALWAYS = new AutoGeneratedTimestamp(AutoGenerateStrategy.ALWAYS);
    private static final AutoGeneratedTimestamp AUTO_GENERATED_TIMESTAMP_CREATE = new AutoGeneratedTimestamp(AutoGenerateStrategy.CREATE);

    @Getter
    @Builder
    private static final class AutoGeneratedTimestampConfig {
        private final String attributeName;
        private final AutoGenerateStrategy autoGenerateStrategy;
    }

    public static final class AttributeTags {
        private AttributeTags() {
        }

        public static StaticAttributeTag autoGeneratedTimestamp(final AutoGenerateStrategy strategy) {
            if (strategy == AutoGenerateStrategy.ALWAYS) {
                return AUTO_GENERATED_TIMESTAMP_ALWAYS;
            }
            return AUTO_GENERATED_TIMESTAMP_CREATE;
        }
    }


    private static class AutoGeneratedTimestamp implements StaticAttributeTag {

        private final AutoGenerateStrategy autoGenerateStrategy;

        public AutoGeneratedTimestamp(final AutoGenerateStrategy strategy) {
            this.autoGenerateStrategy = strategy;
        }

        @Override
        public Consumer<StaticTableMetadata.Builder> modifyMetadata(final String attributeName,
                                                                    final AttributeValueType attributeValueType) {
            if (!AttributeValueType.S.equals(attributeValueType)) {
                throw new IllegalArgumentException(String.format(
                        "Attribute '%s' of type %s is not a suitable type to be used as an autogenerated timestamp attribute. Only type 'S' " +
                                "is supported.", attributeName, attributeValueType.name()));
            }
            final AutoGeneratedTimestampConfig config = AutoGeneratedTimestampConfig.builder()
                    .attributeName(attributeName)
                    .autoGenerateStrategy(autoGenerateStrategy)
                    .build();
            return metadata -> metadata.addCustomMetadataObject(CUSTOM_METADATA_KEY + ":" + attributeName, config)
                    .markAttributeAsKey(attributeName, attributeValueType);

        }
    }

    @Override
    public WriteModification beforeWrite(final DynamoDbExtensionContext.BeforeWrite context) {
        final Collection<String> keys = context.tableMetadata().allKeys();
        final List<AutoGeneratedTimestampConfig> configs = keys.stream()
                .map(k -> context.tableMetadata().customMetadataObject(CUSTOM_METADATA_KEY + ":" + k, AutoGeneratedTimestampConfig.class))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());

        if (configs.size() == 0) {
            return WriteModification.builder().build();
        }

        final Map<String, AttributeValue> itemToTransform = new HashMap<>(context.items());
        final List<String> additionalConditions = new ArrayList<>();

        boolean updated = false;
        for (final AutoGeneratedTimestampConfig config : configs) {
            final AutoGenerateStrategy autoGenerateStrategy = config.getAutoGenerateStrategy();
            final AttributeValue newTimestampValue;
            final Optional<AttributeValue> existingTimestampValue =
                    Optional.ofNullable(itemToTransform.get(config.getAttributeName()));

            if (autoGenerateStrategy == AutoGenerateStrategy.ALWAYS) {
                newTimestampValue = AttributeValue.builder().s(Instant.now().toString()).build();
                itemToTransform.put(config.getAttributeName(), newTimestampValue);
                updated = true;
            } else if (autoGenerateStrategy == AutoGenerateStrategy.CREATE &&
                    (!existingTimestampValue.isPresent() || isNullAttributeValue(existingTimestampValue.get()))) {
                newTimestampValue = AttributeValue.builder().s(Instant.now().toString()).build();
                additionalConditions.add(String.format("attribute_not_exists(%s)", config.getAttributeName()));
                itemToTransform.put(config.getAttributeName(), newTimestampValue);
                updated = true;
            }
        }

        Expression additionalCondition = null;
        if (!updated) {
            return WriteModification.builder().build();
        } else if (!additionalConditions.isEmpty()) {
            additionalCondition = Expression.builder()
                    .expression(String.join(", ", additionalConditions))
                    .build();
        }

        return WriteModification.builder()
                .transformedItem(Collections.unmodifiableMap(itemToTransform))
                .additionalConditionalExpression(additionalCondition)
                .build();
    }

}
